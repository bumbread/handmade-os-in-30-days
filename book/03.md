
## Chapter 03 / Rush into 32-bit mode and introduction to C (day 3) {#ch03}

### 1. Come on, let's create a real IPL {#ch03-01}

Until today we were calling our boot sector IPL (Initial Program Loader), but in fact it never loaded anything. Today I'm thinking about actually loading something.

Since hello-os is a very boring name today we'll change it's name. The name is "papier". It's named after papier mache (paper mash). It's a material that is used for rocks that appear in movies, which are actually made of paper and they are hollow. It has a "looks like a show-off OS, but it's fine for it to be empty inside. We won't overdo it, we'll just take it easy" sort of feeling.

From now on the name will always be "Papier OS", but it won't be an OS, but rather a kind of demo program. Don't worry though, as it'll become a proper OS later.

By the way, if you think about it it's not only the OS that's "papier". Even CPU, even though it doesn't understand the concept of number, but with an addition circuit from the electric signals 0011 and 0110 it produces an electric signal like 1001. It's only the humans who give this operation a meaning like "3+9=12", all the CPU does is silently works with electric signals. The same goes for games -- when you play with computer, it's not like the computer wants to win you, or feels frustration when you win. It just executes the algorithms that have been programmed, but when you play it does indeed feel like the computer feels emotions. But since it's internals are just a program, it's empty. Thus papier. Let's go, papier\~!

Let's start with a simple program. The first 512 bytes of the disk are the boot sector so let's try reading the 512 following the boot sector. I modified the program at once. You can see it in `days/03_v1`

Now, the new part is roughly this:

```
; The part that's been written today

MOV AX, 0x0820
MOV ES, AX
MOV CH, 0                ; Cylinder 0
MOV DH, 0                ; Head 0
MOV CL, 2                ; Sector 2

MOV AH, 0x02             ; AH=02h: read the disk
MOV AL, 1                ; 1 Sector
MOV BX, 0
MOV DL, 0x00             ; Floppy A
INT 0x13                 ; Call BIOS Disk function
JC error
```

To run make sure to change the run.bat:

```
qemu-system-i386 -drive format=raw,if=floppy,file=papieros.img -boot order=a
```

From the new instructions we got only one -- JC. It is short for "Jump if carry", so if the carry flag is 1, it will perform a jump, otherwise execute the next instruction. If you're wondering what is the carry flag I'm bringing out all of a sudden, don't worry I'll explain it soon.

---

Well there's one instruction you may understand the meaning of but have no idea what it does, and that's `INT 0x13`. Of course it's a BIOS function, so we can look it up, and find the following information:

```
Read from disk, write to disk, verify sectors and seek.

parameters:
    AH = 0x02 (read sectors)
    AH = 0x03 (write sectors)
    AH = 0x04 (verify sectors)
    AH = 0x0c (seek sectors)
    AL = number of sectors
    CH = cylinder number &0xff
    CL = sector number (bits 0-5) | (cylinder number & 0x300)>>2
    DH = head number
    DL = drive number
    ES:BX = buffer address
return:
    FLAGS.CF = 0 no error, AH = 0
    FLAGS.CF = 1 error, AH = error code

```

Ooh\~, so since AH=0x02, we're reading sectors!

---

So when you look at return value column, you see an unclear description of `FLAGS.CF`, which is actually just a carry flag. So when you call the function, if there are no errors, the carry flag will be 0 (clear), and if there is an error, the carry flag will be 1 (set).

FLAGS.CF is a register that can only store one bit, and the CPU has multiple registers like that, which can only store a single bit. These registers are referred to as FLAGS register. By setting and lowering the flags the state of the program can be represented.

The carry flag is used to represent the state of carry, but since it is the easiest to handle among the other flags it is often used for other purposes. This time too, it is used to report presense of errors.

---

Let's check the rest. CH, CL, DH, DL correspond to cylinder number, sector number, head number, drive number, which we must set. In our case the cylinder number is 0, the head number is 0, the sector number is 2 and the drive number is 0.

The drive number is used when there are multiple floppy disk. It specifies which floppy disk are you going to read from. In earlier PC's you could insert up to 2 floppy disks, but since today we're not using more than one floppy disk we'll leave DL at zero.

By the way before we told qemu "what" the image file is, but we never told it what kind of disk (floppy or hard disk) it is located on. By default qemu would assume that you're loading the disk from a hard disk, so the drive number would be different (drive numbers for hard disks start at 0x80). So in order to tell qemu to load our image as a floppy, we need to add `if=floppy` parameter to the `-drive` specification, like this:

```
qemu-system-i386 -drive format=raw,if=floppy,file=papieros.img
```

Then qemu will correctly load the file papieros.img as the first floppy disk. But when BIOS searches for the disk to boot from it will first try to boot from the hard disk and fail. In such a case QEMU will display an error message and then start trying loading the image from the floppy. The error messages are inconvenient, so we want to tell QEMU to boot from the floppy directly. We can do it by using the `-boot` specification, in particular the `order=` option. You can make up various orders with this, but today we'll just pass `order=a` (boot from floppy A), like that:

```
qemu-system-i386 -drive format=raw,if=floppy,file=papieros.img -boot order=a
```

So we decided which disk we're going to read from. Now let's move onto deciding where from we're going to read.

If you had a floppy disk you don't need you can cut it open and see that it has black CD-shaped circle. This circle is a fluffy magnetic film. It's a collection of wheels called cylinders, numbered starting from the outside like "cylinder 0, cylinder 1, ..., cylinder 79", and of course it doesn't mean they are made that way at the factory, it's only that way from the perspective of the device that reads and writes the data to that disk. I'm thinking that way for the time being, but I'll explain it in detail later. So the floppy disk has 80 cylinders. By the way we call them cylinders, but considering their geometry, I wonder whether they thought of them as really short overlapping cylinders.

![](media/03_disk_structure.png)

The next up is Head. In this case Head means whether you apply the magnetic head from the top side or from the bottom side. Unlike CD-ROM's, floppy disks are double-sided recording media.

And the last is sectors. If you set the cylinder and head numbers, you'll be able to record many bits of data on that circumference. But since this is too many they divided the circumference even further into sectors. There are 18 sectors per each circumference, and they are named "sector 1, sector 2, ..., sector 18".

To summarize the above, each floppy disk has 80 cylinders, 2 heads and 18 sectors, and since each sector is 512, the total volume is:

```
80 x 2 x 18 x 512 bytes = 1474560 bytes = 1440 KB
```

The boot sector where IPL is located is located at 0/0/1 (this notation has the meaning: cylinder/head/sector), and so the next sector is 0/0/2. And these values are what we want to set.

---

The next thing we don't understand is this buffer address thingy. Since we're reading into the memory, this is for specifying the place in memory where we will read the sector into. If we only used BX for this, we'd only be able to address memory cells `0~0xffff`, so from 0 to 65535. I'm pretty sure that the readers of this book have 4 GB memory or more, but even though you have as much, you only can use 64 KB. This is sad :(

In order to overcome this they made registers like EBX, which were able to address up to 4 GB of memory. This is the maximum memory capacity that the CPU can handle, so there's no problem. But using EBX is something that happened later, at the time BIOS was designed there were no 32-bit registers to use. So for 16-bit processor at the time Intel thought of using a thing called "segment register", which was an auxiliary part of specifying memory addresses.

It's used as an expression like ES:BX, or like `MOV AL, [ES:BX]`. It can also be written like `MOV AL, ES:[BX]`. In that case the actual memory address will be calculated from the values of `ES` and `BX` registers like that: `EX*16+BX`. You can imagine it like roughly specifying the address in memory with `ES` register, and then specifying it in detail with `BX`.

If we set `ES = 0xffff` and `BX = 0xffff`, the result is 1114095 bytes, or 1 MB. It still doesn't quite reach 4 GB, so it seems like at the time, the uncle at Intel thought "It's fine like that". By the way if you heard the phrase "640 KB should be enough for everyone", it partly refers to this 1 MB limit. If you look at the memory map you'd find out that you can't even use the whole megabyte! You can use only the first 640 KB. So the uncle at IBM thought that  what uncle at Intel decided was too large :D

This time `ES` is 0x820 and `BX` is 0. So the place the disk would be read at is 0x8200\~0x83ff. If you thought that somehow it's awkward that we're not starting from 0x8000. But I plan on using the space 0x8000\~0x81ff to load our bootsector, so I think it should be fine.

If you wonder why we're starting at 0x8000, it's because when I looked at the memory map, this space was used by no one. Starting from 0x7c00 it's the boot sector, so starting from 0x7e00 the memory is unused, until 0x9fbff.

---

Until now we never thought about segment registers, but in fact to address memory the segment registers are always used. If the segment register is not specified, usually the `DS` segment is used.

What we thought of until now as `MOV CX,[1234]` actually had the meaning of `MOV CX,DS:[1234]`. And `MOV AL, [SI]` had the meaning of `MOV AL, DS:[SI]`. Writing the same thing every time is tiring, so we usually omit the DS segment.

Since there was such a rule, I had to set DS to zero at the beginnning. If it wasn't zero, that value would get multiplied by 16 and added to the address, so you might have read or wrote to a weird memory address.

Now, if we run the program, well..., if there's an error, an error message should come up, and we don't have any errors come out. That's why if nothing comes up it's a big success.

![Big success\~](media/03_load.png)

### 2. If error, we'll restart {#ch03-02}

From the new instructions we got JNC. This one means "Jump if not carry". Also JE as you might have guessed is also a jump instruction, this time it means "Jump if Equal".

When we got an error, before we repeat reading from the floppy, we call INT 0x13 with AH=0, DL=0. When we look it up this function is "Reset disk system". With this we'll reset the drive and try again. For the rest you should be able to understand it just by reading the program.

### 3. Read until 18th sector {#ch03-03}

Since I'm in the mood for reading sectors let's read more and more sectors following the second sector.

```
; Read the disk
    MOV AX, 0x0820
    MOV ES, AX
    MOV CH, 0                ; Cylinder 0
    MOV DH, 0                ; Head 0
    MOV CL, 2                ; Sector 2
readloop:
    MOV SI, 0                ; Register to count number of failures
retry:
    MOV AH, 0x02             ; AH=02h: read the disk
    MOV AL, 1                ; 1 Sector
    MOV BX, 0
    MOV DL, 0x00             ; Floppy A
    INT 0x13                 ; Call BIOS Disk function
    JNC next
    ADD SI, 1
    CMP SI, 5                ; If the number of failures reaches 5, admit error
    JE error
    MOV AH, 0x00
    MOV DL, 0x00
    INT 0x13                 ; Reset drive
    JMP retry
next:
    MOV AX, ES
    ADD AX, 0x20             ; Advance the address by 0x200
    MOV ES, AX
    ADD CL, 1
    CMP CL, 18
    JBE readloop             ; continue reading while CL <= 18
```

There is one new instruction, which is JBE, "Jump if Below or Equal".

What we're doing here is really simple. If you read the program you'd probably understand it quickly. In order to read the next sector all we need to do is to increase the sector count, CL by one, and increase ES by 0x20. When we add 0x20 to ES, it's as if we're adding 0x20\*16 = 512, the sector size to the destination address. I wrote `ADD AH, 0x20` because I calculated in on the fly in my head, but if you want you can write it like `ADD AH, 512/16`. It will be exactly the same. Ah, wouldn't it then be easier to simply add 512 to BX? Yeah that's right, but this time I wanted to train adding to ES, so for now we'll leave it at that.

By the way, are there any people who thought "why do we have to use a loop?". You're really sharp. Indeed, there's no need to use a loop, we just have to set the AL parameter for the `INT 0x13` read function to 17. If we do that, we'll read sectors 2\~18 (17 sectors total), without any problem. The reason I did it in a loop is because of the following note on the `INT 0x13` read function:

> Number of sectors is set as a number from 0x01 to 0xff (When you do number bigger than or equal to 0x02 additional constraints may apply. e.g. that the specified range can not overlap track boundary or that you can't exceed the 64 KB limit).

Explaining this is a pain, so I'll omit it. Anyway even if you set AL to 17, the function is unlikely to fail, but for what we're going to do next it will exceed the constraints I talked above, so I read the sectors in a loop in consideration for the future development.

As always we don't have any changes on the screen, so we read the sectors from 0/0/2 until 0/0/18 as a `512*17 = 8704` byte chunk spanning in the address range `0x8200..0xa3ff`.

### 4. Try reading 10 cylinders {#ch03-04}

We'll start proceeding further. The sector that's following 0/0/18 is on the other side of the disk, which is 0/1/1. We'll read this into the memory address at 0xa400. Moreover, we'll continue until 0/1/18, and read the next sector which is 1/0/1. We'll slowly advance reading sectors one by one until we reach 9/1/18.

```
; Read the disk
    MOV AX, 0x0820
    MOV ES, AX
    MOV CH, 0                ; Cylinder 0
    MOV DH, 0                ; Head 0
    MOV CL, 2                ; Sector 2
readloop:
    MOV SI, 0                ; Register to count number of failures
retry:
    MOV AH, 0x02             ; AH=02h: read the disk
    MOV AL, 1                ; 1 Sector
    MOV BX, 0
    MOV DL, 0x00             ; Floppy A
    INT 0x13                 ; Call BIOS Disk function
    JNC next
    ADD SI, 1
    CMP SI, 5                ; If the number of failures reaches 5, admit error
    JE error
    MOV AH, 0x00
    MOV DL, 0x00
    INT 0x13                 ; Reset drive
    JMP retry
next:
    MOV AX, ES
    ADD AX, 0x20             ; Advance the address by 0x200
    MOV ES, AX
    ADD CL, 1
    CMP CL, 18
    JBE readloop             ; continue reading while CL <= 18
    MOV CL, 1
    ADD DH, 1
    CMP DH, 2
    JE readloop              ; repeat while DH < 2
    MOV DH, 0
    ADD CH, 1
    CMP CH, CYLS
    JB readloop              ; repeat while CH < CYLS
```

The new instruction here is JB. It stands for ~~Jon Blow~~ Jump if Below. By the way in the source code we use EQU. This is what in C language they call `#define`. EQU stands for "equal". So by writing `CYLS EQU 10` we actually mean `CYLS=10`. Why did we have to make it into its own variable? That's because later we'd want to change it. It will only be 10 for now, later we will change it (By the way CYLS is supposed to stand for "cylinders").

Boot sector is properly completed. If we include the boot sector that was loaded by the BIOS we got `10*2*18*512 = 184320 bytes = 180 KB` loaded from the disk. Now this data is buried within the memory in the address range of `0x08200~34fff`.

### 5. Start writing the OS itself {#ch03-05}

Finally this title came! We've graduated from boot sector.

At first let's just do a simple HLT. So we'll write a very short program.

```
fin:
    HLT
    JMP fin
```

We'll name it `papier.asm`, and by assembling it with NASM we'll get `papier.sys`. This is not anything complicated.

Then we'll save this file onto the disk image. The meaning of saving the file onto a disk image may not be clear. This is essentially the same as doing the following:

- Creating a disk image once and writing it onto a disk
- Opening the disk with windows and saving the files there
- Get the disk image from the disk back using a tool

Note that we start with the disk image and end up with disk image. It would be nice if we could do this with just a disk image and the file, without needing to write it into the disk. This is what I mean by saving to the disk image.

I wrote a program that creates floppy disk images from bootsector and a folder with files. The disk/ folder in days/03_v5 is the folder, the contents of which would be saved to disk.

---

In days/03_v5 I modified the build script to include our OS file into the disk image. Let's create the image file with our make.bat. Now open it with a hex editor. We'll look at how this file is recorded onto the disk.

First we see on offset 0x002600 the filename `PAPIER` `SYS`.

(include screenshot of the offset. Fuck my tool has a bug here)

Then we'll look at offset 0x004200. The bytes `F4 EB FD` are written in there. If you're wondering what these bytes are, try peeking into papier.sys with a hex editor. You'll see these three exact bytes.

(screenshot at offset 0x004200)

When you save a file onto an empty disk the following happens:

- At offset 0x002600 the file name is written
- At offset 0x004200 the file contents is written

This is all I wanted to know, as soon as possible.

If you understood this what we shall do now is very simple. After we created papier.sys and saved it to the disk image, so now we should load it and execute from the boot sector. That's what we'll do.

### 6. Running OS from bootsector {#ch03-06}

Now, the image file is located at the offset 0x004200, but what do we do to execute it? The start of the disk image in memory is at 0x8000, so 0x004200 in memory would be `0x8000+0x4200 = 0xc200`.

Let's write `ORG 0xc200` in papier.asm, since this is where it would be loaded into the memory. After that we'll add `JMP 0xc200` after the sector loading in `ipl.asm`.

Let's run make.bat right away. For now nothing happens. Does that mean it loaded correctly? Let's output something from papier.sys.

### 7. Check the operation of the OS {#ch03-07}

This something is well, writing a message again is boring and not interesting. So I'll make a screen like in Windows, so the first thing we'll do is to change the screen mode.

```
.
```

Changing the screen mode is done with BIOS 0x10 where AH=0.

```
Set video mode
    AH = 0
    AL = mode (minor modes omitted):
        0x03 - 80x25 16-color text mode
        0x12 - 640x480x4 bit color VGA graphics
        0x13 - 320x200x8 bit color VGA graphics
        0x6a - 800x600x4 bit color Extended VGA graphics
return value:
    none
```

For now we'll switch to the 0x13 screen mode. 8-bit color means that we can use 256 different colors, doesn't seem too bad.

When you switch modes the screen is supposed to go pitch-black. In other words by seeing whether there was any change we'll be able to see whether our OS correctly loaded. Since it's a graphics mode the cursor would also disappear.

Let's build our OS and run it. We should see a pitch-black screen.

(picture)

Ooh the screen is pitch black. This means we did well. Banzai!

### 8. Prepare for 32-bit mode {#ch03-08}

We've got some time left today, so I thought to continue.

From now on our target will be development in C rather than assembly, so we'll make this our focus.

The C compiler we will use, GCC is a 32-bit compiler. It can only generate 32-bit machine code. It's not really so much that it can't otherwise, but even if we force it to generate 16-bit code, we'd only be met by hardships. So we'll switch ot 32-bit mode.

The 32-bit mode is one of CPU modes. In PC's CPU there is 16-bit mode and 32-bit mode. When it starts up, the processor is in 16-bit mode. Also the machine code for 16-bit and 32-bit modes is different so the 16-bit code won't work in 32-bits, nor the opposite is true.

In 32-bit mode the memory beyond 1 MB can be used. In 32-bit mode there are protection features that make it possible to protect from e.g. weird machine language. So I want to switch to 32-bit mode that does all these nice things.

---

But in 32-bit mode we can't use BIOS functions. That's because BIOS is written for 16-bit mode. So in 32-bit mode whatever BIOS did for us we would have to do ourselves.

We already used BIOS to set the screen mode, but now I want to use BIOS to learn keyboard state, for example whether Caps Lock is pressed.

I have modified papier.asm:

```
; papier.asm
CYLS EQU 0xff0
LEDS EQU 0xff1
VMODE EQU 0xff2
SCRNX EQU 0xff4
SCRNY EQU 0xff6
VRAM  EQU 0xff8

ORG 0xc200

    MOV AL, 0x13
    MOV AH, 0x00
    INT 0x10
    MOV BYTE[VMODE], 8
    MOV WORD[SCRNX], 320
    MOV WORD[SCRNY], 200
    MOV DWORD[VRAM], 0x000a0000

    ; Keyboard BIOS
    MOV AH, 0x02
    INT 0x16
    MOV [LEDS], AL
fin:
    HLT
    JMP fin

```

### 9. Finally introduction to C {#ch03-09}

### 10. Anyway we want to HLT {#ch03-10}
