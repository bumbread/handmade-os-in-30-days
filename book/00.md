
## Chapter 00 / Before the development {#ch00}

### 1. Introduction  {#ch00-01}

You have probably seen tutorials that teach you how to make your own game from scratch. You may have at least once in your life opened Notepat and created your first web page. There are also lots of tutorials that teach you how to create various graphical applications like calculators, text editors, painting applications, etc.

But when it comes to Operating System development there's suddenly less tutorials and less people experimenting with it. For some reason OS's are thought of as complex and advanced things. I think it's because of the lack of tutorials aimed at beginners.

If you consider Operating Systems like Windows or Linux, they are so big they take up multiple Gigabytes of disk space. If you did make something like that as a hobby alone, it will take a desperately long amount of time to make something like that. Definitely, they're big, but it won't take lifetime to finish them, even I think so.

But no worries needed! I have the experience of developing a small OS, which doesn't even take up 80kb of space. Even though it's small, it's a properly-featured OS. It does actually have a proper graphical interface it doesn't omit multitasking (ability of the OS to execute multiple programs at the same time).

Since it's only about 80kb, doesn't it feel like you can create something like this if you try apply some effort? Don't you feel like even a beginner could create something like this? Yes, it can be made in about a month! With that said let's take it easy.

Even if you don't think about creating your own OS, this book still might be interesting to you. When you read a book about building a PC, you learn all about which parts a PC is made of and how and where the performance is decided. When you read about how to develop games, you start to understand the structure behind what makes the games tick. Likewise, when you understand the process of making an OS, you'll start to see the structure of the other OS'es and what makes them work. So if you have interest in these things, please consider reading a bit.

Also this book requires very little knowledge. It certainly helps if you have some experience writing programs in any programming language, but you might also get away without that prior experience. There is a lot of C in this book.  If you've been studying C and gave up because it was too hard it's also fine. Of course, the more things you know the easier the reading will be, but I'm explaining things carefully so rest assured.

In this book we will develop an OS for IBM PC/AT compatibles. Generally, this includes all computers that can run Windows. These computers have an i386 (x86) compatible processor. For other models of computer like Macs, which have a different architecture, and even sometimes a different processor architecture, only some parts of the book can be taken for a reference, but you won't be able to follow the tutorial on such PC.

You don't have to worry about the size of RAM or hard disk. If the requirements above are met even old and slow models are fine.

For the development you have to have a 32-bit or a 64-bit Windows operating system installed. Linux also works, the only thing is the instructions won't be as detailed for Linux users, and you'll have to find alternatives to some of the programs mentioned here.

### 2. What is an OS? {#ch00-02}

There are a few commonly accepted definitions, but in this book I will not give them. Because even if I gave you a definition, all I would have to do is to write a simplest program that satisfies this definition. This would be easy for me, certainly. But it wouldn't be fun for the readers, more than that, it would break some expectations.

Rather than trying to satisfy definitions I want to satisfy readers' expectations. Which is why we'll make an OS where you can move windows around, poke into the buttons and run applications, like calculator or games.

### 3. How we'll make an OS  {#ch00-03}

There are different ways to make an OS.

I think that the best way to make an OS is to find an existing OS that is the closest to the one you want to make and modify it according to your liking. This will take the least time to make.

But in this book we won't do that, instead we'll do everything from scratch. I want to introduce you to OS development in a general way. Since we'll be creating everything from scratch the book will be longer. Try reading it leisurely. The author already wrote it carefully.

As to what programming language we'll use, I think we'll go with C. Ah... I can hear the dissatisfied voices (bitter smile). Like "C is not good", "I want to do it in C++", "Java is good", "Let's rewrite it in rust", ... I understand your feelings, but trust me, with C the explanation becomes the simplest. C doesn't have many functions, which makes it easy to use, so it is the right language for this book. If we used an other language, I'd have to first give the explanation of that language, which is daunting.

It's a bit sudden, but here's one tip to teach you how to make an OS from scratch. Don't think about how to suddenly make an OS from scratch. You just have to make something that looks like an OS. Because when you think about making an OS you think that you have to do this, or do that, and your head fills up with these things and it just becomes tedius. What to hide, I myself have been repeating this frustration for multiple years. So the motivation isn't that in this book we're making an OS, but rather a demo that looks like an OS. And strangely enough, when making this demo it becomes not a demo but a full OS.

### 4. Is naiveness ok? {#ch00-04}

When you try to make an OS there surely will be people around you that sprinkle jargon at you such as what the kernel is, what about the shell, whether the kernel is monolithic or microkernel and so on. It may be beneficial at times, but having that told suddenly is bothersome.

In order to keep people around you quiet you have to study these things and show a certain view, but to be frank such complicated things are unnecessary for beginners. You'll just spend a lot of time studying to then end up despairing over how shallow your ideas are compared to world's operating system or you'll be so overwhelmed that you'll just end up combining their techniques, which is not fun at all.

So let's go without studying. Even if you learn jargon and reasoning, knowing only that is not interesting. It doesn't matter how rudimentary your OS will become, as long as you have fun it's fine. Moreover, it's better to try create a simple OS once, see the places where problems arise, then learn what is proposed to overcome these problems. This will let you understand complex theory in depth. As a result you won't have the answer for the naggers. In the meantime I'll just have to ask you to talk about it with someone else, because I want to do it at my pace.

---

On the other hand not knowing is also a good thing. Because you don't know anything, you can also do very silly things experts would laugh at. It's a good thing that we don't know anything. Sure, most of the time it's just plain stupid, but sometimes I discover something amazing that experts have overlooked (!). Experts have a lot of preconceptions, so there are quite a few things that they can't do even if they haven't tried it, or that they have decided it's no good after a while. Only trying to be ignorant like us can challenge these things. Anyone can become an expert by studying, but once you do its very hard to regain the state of being the beginner. So let's try, at least in the beginning to do as much as we can in ignorance. And if we hit a wall, we can just learn the things that are necessary at that time.

That's exactly what I did, and that's what I'm doing now. I never went to school for programming, and I started to build an OS without learning much of hard theory. But thanks to that I've been praised by many experts, and I've even been given the opportunity to write a book about OS development for beginners. And ever since starting, I've enjoyed every single day developing it.

Since we'll be working by exploration, the story will be easy to understand. However we'll be making mistakes and reworkings, so for those who understand what's going on that may be frustrating. I'm sorry, but you'll have to put up with that.

It may sound like we shouldn't study, but that's not true. If you have to make a program for your job or you have to do this much in a year, then you don't really have the time to go the roundabout way, so it's much better to study before you start making unnecessary mistakes. But this time, I'm making it as a hobby. I want to do it at my own pace, so this is fine.

### 5. Recipe to obtain an OS {#ch00-05}

The OS starts automatically when the power is turned on. How do we make such a thing? An executable file (\~.exe) created on Windows doesn't start unless you double-click on it with your mouse. This isn't what we want to make, what we'll do is put the disk with our OS into the PC, or put the OS onto the hard disk and turn on the power. After we turn on the power the OS should start automatically.

In order to do this we'll perform the following steps:

1. Write the code for the OS using Windows
2. Obtain the machine language for the OS by compiling the code
3. Create the disk image file by writing the OS code into it
4. Get the bootable disk with your OS by writing the disk image onto the disk.

In other words basically creating an OS means creating a disk that contains the OS and somehow starts automatically.

The disk image file, simply speaking is the backup data for the disk. We want to make a disk with certain content, but we can't directly apply magnet to it and arrange the bits of the data ourselves, really. Therefore by first making up the backup data and writing that data to the disk, we can make the desired disk.

For example, the total capacity of all floppy disks is 1440kb, so the image file that is backup data is also 1440kb. Since you're free to create any backup image, it's possible to create disks with any content. It's also possible to create the image file that has less volume than the target device. So if your USB thumb drive is 32gb in size, you can still write the 1440kb image file to it just fine (the other bytes would just get untouched).

I would like you to pay attention here. We're using another OS (Windows) to create our OS. The reason for that is that to use text editor or a C compiler you need an OS running. But what about the world first OS? Of course there's no OS to create the world's first OS. That's why these programmers looked at the CPUs instruction code tables, lined up zeroes and ones, and wrote them to the disk (probably not a disk, but another storage device at the time). This is a very difficult task. So maybe the first OS is one with a lot less functionality, and once that OS is created, they used it to create a slightly better OS, and then make a practical OS with that OS... I think they did something like that.

### 6. Hardships {#ch00-06}

The C compilers on the market are designed on the premise of creating Windows and Linux applications, and it is less commonly used to create other things such as original OS. Since we're not using any kind of compiler that's made specifically for the OS development, there are inconveniences that arise. There is certain functionality that is implemented by OS, or requires additional OS setup before it can be used. But since now we're writing OS, we won't be able to use this functionality, so we'll have no choice but to disable it.

Therefore to write our OS we can't use just any compiler, but the compilers that have the ability to disable certain functionality that can not be used with OS code.

For example take the function `printf("hello\n");` a function that appears at the beginning of every C textbook. We can't use it. Because printf is a function that has to be provided by the OS. But we haven't created the OS yet. Even if you write this function, you wouldn't be able to compile the code, because we'll be telling the compiler to not use any of our OS's built-in functions. printf is not the only function that cannot be used. Most C functions can't be used.

There are more examples of such functionality, but it will require you to know a lot more about code generation and compilers, so I won't say what it is, but I will say how to disable it, so you'll be up and running as soon as possible.

If you let me excuse myself, I chose C language this time because there are not so many functions in C language that rely on the OS. Basically forgive me for deciding a language solely on the number of functions. For C++, the basic and important operators such as new/delete can't be used and there are various ways the classes are created, so the good parts of C++ cannot be utilized. Of course, you can build your OS in a way where you can use these. You can overcome this. Though it is frustrating to think about whether you're making an OS **in** C++ or an OS **for** C++. In other languages the situation might have been even more difficult. So please forgive me.

By the way assembler is probably the only language that has no restrictions when creating an OS. It's truly the greatest programming language that exists there. Although if I was to write a book like "Let's make an OS with only assembler", very few people would actually read it, so only a reckless writer would do something like that.

Also when creating an OS it is necessary to play with CPU hardware directly. But since C compilers are made for application development there is no way to operate these registers directly.

So, in order to overcome these problems the parts that can't be written in C have to be written in assembler. At that time you have to be aware of how C compiler translates your program into machine language. If you don't, you won't be able to exchange information with parts made in the C language.

Similarly, if you plan to build an OS in C++ you have to know how that language is translated into machine language. Naturally C++ is more complex than C, so the translation rules are more complicated and cumbersome, that's one more reason I decided to go with C. At the end, if you don't know how the language is translated into machine language you can't build an OS in that language.

The tutorials on programming languages rarely cover the way the languages are translated to machine code. So I will have to write about this in this book.

This kind of experience may change how you think about programming. Even though until now I was thinking about making a cool and beautiful source program, I noticed that how it's translated into machine language is also important! No matter how cool your source code is, if it doesn't come out with the right machine language it won't work and it won't make sense. On the other hand if the source code is dirty and can be compiled with a specific C compiler, it's okay if it becomes the target machine language. Once you get the machine language you want you can just throw away the source code! I wouldn't say a thing like that, but having that feeling is nice.

For OS developers source programs are a "means" of obtaining an OS, not a "purpose". If you're too focused on the means and it becomes a hassle you will get overwhelmed.

Oh, by the way, the fact that we're making an OS in C and assembly doesn't mean that C++ applications won't work on it. The language we use to create the OS has nothing to do with the languages which the OS supports. So don't worry about that.

### 7. About further reading {#ch00-07}

Starting from chapter 1 the chapters correspond to days of development. The book is divided into days, but I divided it as I was writing, with respect to my current abilities and the lengths of explanations. Whether people find explanations difficult depends on the person so it's quite possible that a single day may take you a week or, on the countrary 3 days may take you a single day.

Of course there are some things you don't understand when you read. In such case it may be a good idea to continue reading for a day or two. Then you may suddenly figure it out. But sometimes, I think, there are cases where you might not understand even after that. In such cases verify how well you understood and it's fine if you return back. Don't rush because it may turn out to be sloppy.

Sometimes it's clear what you know and what you don't know, and no matter how many times you read back what you don't understand, you can't start understanding it. In such cases get help from the community by asking a question.

---

The way of explaining pointers in C is different in this book. That's because in this book you will first learn how the CPU works, learn how to do it in assembler and after that study the C language. In other books they don't talk about the basics so when they talk about pointers they suddenly say something about the address of the variable. So if you think you know pointers from other books or tutorials please read this book as well, you will get it. If you really know what you're doing feel free to skim the explanation.

I will build the OS little by little, explaining what I am doing as I develop it. But note that sometimes I will make changes and omit the explanations. So in that respect this book is more like a summary, not a complete tutorial.

For example the first program in the appendix is "code/01/1", and the program that appears next is "code/01/2". The folders in the code folder correspond to chapters (days). In each folder for the chapters there are folders corresponding to the sections of that chapter. So if you follow the instructions in day 1, chapter 1, the source code will become "01/2", wouldn't it? No it won't. That's because sometimes I do some changes behind the scenes. I just didn't explain it because I thought you would understand it without the explanation.

So after all what I want to say is don't just read text, but also look at the programs properly. It's also possible that explanation in text are vague, but once you look in the code it'll immediately become clear. So the center of this book is not the text, but rather the program in the appendix. The text is just an explanation of how the program in the appendix was created.

Introductions are introductions, not complete explanations. Please be careful not to make a mistake... In that sense rather than "Book and the code as appendix" it may be "Code and a book as appendix", hehe :D

