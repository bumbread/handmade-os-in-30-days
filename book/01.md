
## Chapter 01 / From PC structure to assembly (day 1) {#ch01}

### 1. Short Command Line intro {#ch01-01}

The majority of the programs that we will use are not graphical. They use an older, the more classical interface, which is the command line interface. If you used the command line before feel free to skim this chapter.

Note that this explanation is not a complete explanation of command lines. If you think you got into a problem with command line, you probably should ask someone about getting help. Because windows command line is not a simple tool to use.

In any case you should know that the command line is a handy tool. Learning it requires some patience, but it does pay off at the end, especially if you plan to do programming-related work.

You can open command line either by finding and launching the executable `C:\Windows\System32\cmd.exe`, or by using the shortcut `Win+r` and then in the appeared window type "cmd" and press Enter. A window like this should open:

(screenshot of the window)

In this window you can type commands and get back the result. The examples of the commands are `dir` (prints contents of directory), `type <filename>` (prints the contents of the specified file), or `cd <dir>` (changes current directory to the specified one, if nothing is specified prints current working directory).

You can try typing these commands. You don't have to worry, you shouldn't be able to break anything with these commands, since they mostly display information.

Now use whatever method you know to create a directory, where you will be developing your OS. I recommend something with a short absolute path, and no spaces in between, something like `D:\my_cool_os`. Then use `cd` command to switch to that directory. According to the above example that would be:

```
> cd D:\my_cool_os
```

You should notice that the prompt of the command line changed. This is because the path in the prompt indicates the current directory. Essentially it displays to you the same information as `cd` does.

Now, let's talk about the identity of these commands. The `type` command is actually an executable, a program that's located at `C:\Windows\System32`. You can also call it from your command line by entering

```
> C:\Windows\System32\type.exe <some_file>
```

In the case of .exe files, we can omit the extension:

```
> C:\Windows\System32\type <some_file>
```

Some commands are programs, while other commands like `dir` and `cd` are not programs, they are part of `cmd.exe`'s command line interpreter.

But how exactly does windows know where `type` is located? We are able to simply enter `type.exe`, and Windows would understand that by that we mean `C:\Windows\System32\type.exe`, independently of our current working directory. Well, you might think, windows knows that `C:\Windows\System32` is somehow special. And you'll be right, it is. In fact you can make any folder you want "special".

Whenever you enter something like `type`, Windows starts searching first in the current directory. If there's no `type.exe` in the current directory, Windows searches the special system setting called `%PATH%` environment variable. You see, these environment variables are just like variables in programming language, except they are operating-system wide. %PATH% is just one of these variables that holds the search paths where the programs can be found.

You can look at the contents of your %PATH% variable you can type:

```
set PATH
```

This should print a string that represents the contents of the PATH variable. The contents normally look something like `path1;path2;path3;...;pathN`. So the output of the above command would look something like:

```
PATH=path1;path2;path3;...;pathN
```

(edit environment variables window open)

Now you can insert a semicolon and add whatever directories you want into this PATH. I suggest you add the directories where the NASM, QEMU and GCC executables are located. Because we will use these programs a lot.

Right now you can empty your OS directory and continue following this book. From now on I won't bother you about the command line commands. You won't use it for much except running programs anyway.

### 2. Let's start! {#ch01-02}

Well it's easier to make the OS than to write about it, so we'll start development right now. And so as if ignoring the introduction, I will start developing not in C, nor in assembler, but with a different tool :D

There are programs called Hex Editor. They are used to edit the bytes of a file directly. I would like to use such a program to create a file with contents shown below.

![](media/01_os_bits.png)

There are many zeroes so I recommend you abusing the hell of copy&paste feature of the hex editor you're using. After you're done, save the file under the name `os.bin`. Make sure it is exactly 512 bytes long. You can do this by typing `dir` command. It should show the sizes of the file on the right to the names.

If you'd written this image to any disk (like USB stick or an SSD) you would be able to boot from it and get a working OS. To do this you can use Win32DiskImager.

To install the disk image onto USB first open Win32DiskImager. Choose the file that you want to write, in our case that's os.bin. Chose the disk to write to and make sure that the disk it writes to is the correct USB (it might make the data on your USB unaccessible). Then click "write" and confirm.

---

In order to test our OS you need to write the image onto USB and make your BIOS recognize USB as the first boot option. This is done differently depending on the particular BIOS you have so I won't describe this procedure. If you don't do it, your PC will boot back into Windows.

If your motherboard has UEFI, make sure that UEFI will either autodetect whether to use BIOS or UEFI, or set it to BIOS. About the BIOS and UEFI I won't talk much here, because the explanation is long and messy, and you're not likely to understand it without better theorhetical background, but in essense UEFI is "like BIOS but better". In our case we'll be using BIOS, just because it's simpler and modern PC's still support it.

---

There probably are people who don't want to bother buying a USB or restarting their PC. In such a case you can use an emulator.

To use an emulator launch a command line (first use of command line!). To start qemu from console type:

```
qemu-system-i386 os.bin
```

Into the prompt. Make sure the folder where `qemu-system-i386.exe` is located is in PATH environment variable. Now QEMU should start displaying the string "hello world" (potentially among other text).

If you do that you may find the following message:

```
WARNING: Image format was not specified for 'os.bin' and probing guessed raw.
         Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted.
         Specify the 'raw' format explicitly to remove the restrictions.
```

This is fine, because we're not attempting to write to the image. But in the future, when we would like to perform writes to disk, they would be rejected by QEMU. So we would like to get rid of this warning. In order to fix the warning you have to specify disk image using `-drive` option, while explicitly saying it is a raw image, like this:

```
qemu-system-i386 -drive format=raw,file=os.img
```

Make sure you *don't* put space after the comma. This `-drive` option will tell QEMU that we're explicitly loading a raw image, and tell where the file of that image is.

If your image doesn't work, make sure that all the bytes are correct. In any case you should be able to get the os.bin from days/01/2 to work.

---

Now what you should get is something like this:

![](media/01_os_screenshot.png)

So well, we've come to a point where we built our own OS without modifying other OS'es (if you accept it as OS). This is amazing. I think it's good if you show it off to your friends. Letting the beginner make an OS from absolute scratch in just a few minutes -- this book has got to be good, haha. Since inputting is hard this time we only output a message to the screen, but if you keep typing for long enough, in principle you can make any OS. One problem is that we don't know what these "b8 00 00 8e d8..." mean (though it's also the biggest problem). So the rest of today and the next 29 days will essentially explain nothing but that.

### 3. What did we do? {#ch01-03}

So whatever fancy tools we use, be it a hex editor, or a fancy compiler toolchain, at the end it will come out to be the same `os.bin`, with maybe perhaps a slightly different content. Let me explain why we can only make an OS like that.

We'll start with what the PC actually is. The center of all the processing in the PC is the CPU. CPU is short for Central Processing Unit, so it's obvious that it's in the center. Even if another device was the center of all processing that device would be called the CPU. At the end CPU is always the center of processing. So this CPU can't do much but send electric signal to other circuits. Moreover it can only understand two kinds of signals: ON and OFF, so it's a pretty incompetent device.

We use the PC to write text, listen to music, process images and much much more. In any case the CPU just sends out electrical signals that are either OFF or ON. The CPU doesn't understand the contents of the sentence, the pleasantness of music nor the beauty of the photos. I'd say that it's more like "If you combine these electrical signals like this you will get an electrical signal like that". You can instruct the CPU to perform calculations like addition, subtraction and even multiplication and division of integers. You can also use negation, and not only that, you can use fractions and numbers as big as 10^100. You can extract square roots, which is taught in middle school and you can use the trigonometric functions, taught in high school, with just a single instruction. But the CPU doesn't even understand the concept of a number. It just reacts to these electrical signals and answers with the corresponding electrical signals.

Since the explanation became a bit hard to understand let's be specific. Let's assume that ON is 1 and OFF is 0, that way it will be easier to understand. If we do that, 

![](media/01_bits.png)

These 8x16=128 ON's and OFF's signals will represent this picture.

The string of the following 32 electric signals:

```
00000000000000000000010010100010
```

Represents the integer 1186 (Note: if you write 1186 in binary it will be 10010100010). Moreover,

```
01001011010011110100111101000010
```

These 32 electric signals represent the word BOOK (Note: this is how it's actually represented in the PC).

So if these signals are passed, the CPU doesn't know at all whether its part of an image, or a sound wave, whether its a number or part of a sentence, whether its part of a program or a game's save data. It doesn't know, but it doesn't worry about these things, it just silently executes the program.

---

Originally the CPU has been been developed as a device that processes only electric signals. No one thought that it'd become such a useful machine. However by associating OFF and ON with numbers 0 and 1 it was possible to treat electric signals as binary numbers, and on the countrary binary numbers can be treated as electric signals, so it became possible to use it as a binary computer.

Decimal numbers can be converted into binary numbers and binary numbers can be converted back into decimal. So it was possible to do ordinary calculations. Additionally, by assigning numbers to characters (these are also called character codes) it becomes possible to process sentences (like searching through text). After that they learned how to make music and pictures correspond to electronical signals so it became so the range of use for the CPU steadily expanded. But even then CPU is only processing electric signals.

What's more, the CPU not only processes the data. Instructions to the CPU are given by the electric signals. The program we're creating is that machine language, but this machine language is sent to CPU in the form of electric signals. This is just a series of numbers for instructions, so of course its just a bunch of zeroes and ones.

Hard disks simply replace zeroes and ones with magnetic N's and S's. So image files can only be written as zeroes and ones. Not only image files, but any files on PC can only be written as zeroes and ones. Rather, anything that can't be represented as zeroes and ones can not be passed to the CPU as electric signals, so it can't be processed by the PC.

---

With hex editor you can enter whatever blob of binary data and create a file. That's why it's the ultimate strongest weapon. There does not exist a file that can't be created with a hex editor (Oh\~!). If you want some software sold at the store, but you can't buy it, you can just enter it at home with a hex editor. With this you can create exactly the same thing as in the store. Don't worry if you can't buy a 5MP digital camera. As long as you have hex editor you can create any image file that is exactly the same as the JPEG files taken by 5 megapixel digital camera. Don't cry about not being able to get an expensive C compiler. With a hex editor alone you can create an executable file with the same result as the compiler would generate. More than that you can just create the compiler itself!

Since it is the strongest tool, we can create an OS with it. So its obvious why today we rather awkwardly, but made an OS. You may wonder whether there was any need to put up such a long explanation just to say this. But once you understand the basics of CPU, the story in the further chapters will be much more clear. For now please accept it for what it is.

You might have noticed that when using hex editor you didn't enter the binary data directly. In that case what were we entering? In fact we were entering the binary data, just written in a different form.

Binary numbers have excellent compatibility with electric signals, but they have a lonely drawback of having a lot of digits. For example if you write 1234 in binary numbers you get `10011010010`, which is just 11 digits. In decimal it was just 4, right? That's a waste of paper so we use hexadecimal numbers in this industry. In hexadecimal 1234 becomes `4D2` which is just 3 digits.

If you wonder why would I bring out hexadecimal all of a sudden where decimal should have worked just fine, but in fact it's because binary is very easy to convert to hexadecimal,

<table>
    <tr><th colspan=4>Binary &lt;=&gt; Hexadecimal conversion table</th></tr>
    <tr><td>0000 = 0</td><td>0100 = 4</td><td>1000 = 8</td><td>1100 = c</td></tr>
    <tr><td>0001 = 1</td><td>0101 = 5</td><td>1001 = 9</td><td>1101 = d</td></tr>
    <tr><td>0010 = 2</td><td>0110 = 6</td><td>1010 = a</td><td>1110 = e</td></tr>
    <tr><td>0011 = 3</td><td>0111 = 7</td><td>1011 = b</td><td>1111 = f</td></tr>
</table>

So by taking our binary number, we can separate it into 4-digit sequences, and then using the table above to convert each one of these sequences into a single hexadecimal digit,

```
100 1101 0010 -> 4D2
```

We get `4D2`. Similarly, `4D2` can be easily converted to `10011010010` by doing the opposite. Decimal can not be converted to binary as easily. And for the same reason octal notation, which separates binary numbers by 3 digits is also used.

That's why when you typed `B8` you typed `11011000`. In general 2 hex digits correspond to 8 bits, or a single byte. This is a fact worth remembering.

---

I do compliment hex editors extremely, but its not much different from saying "You can write any great novel with just a piece of paper and a pencil". Paper and pencils are paper and pencils, they are not easy to write great novels. That's why everyone uses a text editor and a compiler when they write programs, not a hex editor. Also when taking photos a digital camera is used, not a hex editor. That's why we also will stop using a hex editor and use a programming langauge from now on. But anyway, a hex editor is a tool useful in cases of emergency. So I will use it in the case of an emergency from now on.

### 4. First assembler experience {#ch01-04}

So now let's use an assembler to generate exactly the same os.bin as before. We will use an assembler called NASM, which is quite famous in free software.

We could rewrite our program like that:

```
db 0xb8,0x00,0x00,0x8e,0xd8,0xea,0x0a,0x7c
db 0x00,0x00,0xbe,0x22,0x7c,0xbb,0x00,0x00
db 0xb4,0x0e,0x8a,0x04,0x83,0xc6,0x01,0x3c
db 0x00,0x74,0x04,0xcd,0x10,0xeb,0xf3,0xf4
db 0xeb,0xfd,0x48,0x65,0x6c,0x6c,0x6f,0x2c
db 0x20,0x57,0x6f,0x72,0x6c,0x64,0x21,0x0d
db 0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x55,0xaa
```

You can see that the data is the same as the data you typed into a hex editor. The `db` instruction is short for "data byte", and means write 1 byte with a given value into the output file. You can write multiple bytes by separating them with a comma. You should see how this would make the exact same image when we compile this file.

But I would like to spare your hands on such a trivial manner, and teach you another very helpful instruction. This is a `times N` instruction. This instruction repeats the given instruction `N` times.

We can use this to duplicate the `db` instructions. For example if we were to type:

```
times 5 db 0
```

This would duplicate `db 0` instruction 5 times, in other words this is equivalent to:

```
db 0
db 0
db 0
db 0
db 0
```

Or alternatively:

```
db 0, 0, 0, 0, 0
```

Since most of our file is zeroes, we can efficiently use this instruction to our advantage.

```
db 0xb8,0x00,0x00,0x8e,0xd8,0xea,0x0a,0x7c
db 0x00,0x00,0xbe,0x22,0x7c,0xbb,0x00,0x00
db 0xb4,0x0e,0x8a,0x04,0x83,0xc6,0x01,0x3c
db 0x00,0x74,0x04,0xcd,0x10,0xeb,0xf3,0xf4
db 0xeb,0xfd,0x48,0x65,0x6c,0x6c,0x6f,0x2c
db 0x20,0x57,0x6f,0x72,0x6c,0x64,0x21,0x0d
db 0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
times 432 db 0
db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
db 0x00,0x00,0x00,0x00,0x00,0x00,0x55,0xaa
```

Now this program is much shorter! You can save this as os.asm. We can compile the program using nasm command like this:

```
nasm os.asm -o os.bin
```

Launching os.bin the same way we did before we should also get "Hello, World!" output to the screen.

By the way I made days/01/4 folder by changing the name of days/01/2 folder, removing unneeded files, and adding the necessary files. That's how the folders are growing little by little.

---

The `db` instruction is the ultimate strongest weapon in the world of assembler. That is, any data (and any program, by the way) can be written with just that instruction. That's why there are no files that can't be created in assembler. You can create text files, image files, whatever you're told to do, you can do it in assembler. This versatility(?) is rare in other languages (e.g. C).

---

If you add "0x" in front of a number, it is a hexadecimal number, and if you don't add it, its a decimal number. That's the same as in the C language.

### 5. Let's rewrite it a little more {#ch01-05}

I'm really happy with 22 lines, but it still has no meaning. So, I added a bit of meaning to it. The file has increased in length to 50 lines. You can find it in days/01/5. Now you don't need the days/01/4 folder. You can delete it or keep it as a keepsake.

The file is 50 lines. I don't think it'll hurt if I leave it on the page.

```
; The program
db 0xb8,0x00,0x00,0x8e,0xd8,0xea,0x0a,0x7c
db 0x00,0x00,0xbe,0x22,0x7c,0xbb,0x00,0x00
db 0xb4,0x0e,0x8a,0x04,0x83,0xc6,0x01,0x3c
db 0x00,0x74,0x04,0xcd,0x10,0xeb,0xf3,0xf4
db 0xeb,0xfd

; The data
db 'Hello, World!', 0x0d, 0x0a, 0x00

; The rest of boot sector
times 510-($-$$) db 0
db 0x55,0xaa

```

For the new highlights, `;` marks a line comment, equivalent to `//` in C or C++. Thanks to these, you can add various comments into a source program.

Btw there's another way to use `db` instructions. You can specify strings of text. For this you can use either `'` or `"`. And you can specify additional data after the comma.

Oops forgot to explain `510-($-$$)`. You can read the value `($-$$)` as "number of bytes from the beginning of the program". In this program there are 34 bytes prior to this line so `($-$$)` here is 34. That's why NASM subtracts 34 from 510 to get the answer 476, so it will fill the 476 bytes with zeros.

In that case it seems like you should just write 476 directly without using `$-$$`, but with this if you change the message from "Hello, World!" to "This is my cool OS", how many zeroes it should put will change automatically. That's important because if you don't get `55 aa` at 510-th byte, you won't be able to boot from the disk. If you write the problem using the offset from beginning, the assembler will do all the calculations of how many zeroes you have to enter so you can easily modify the program.

This makes it easy to modify the messages, so please modify them according to your liking. This way you can get the only OS in the world with that message, your personal OS.

Finally, I will explain the technical terms that appeared in the source program. That would be enough for today.

**Boot sector**. The first sector of a disk. The question is "what is a sector?". The hard drives and floppy drives were designed to read 512 bytes at a time. That's why 512 bytes is called a sector. A floppy disk is 1440 KB or 1474560 bytes, but if you divide this by 512 you get 2880. So the floppy disk consists of a total of 2880 sectors. So why is the first sector called a boot sector? The PC first reads the first sector of the disk. Then it looks at the last two bytes. If it isn't 55 AA, it determines that the disk doesn't have the program needed to boot, and you'll get an error saying that the disk is not bootable (You might wonder "why 55 AA". The people who created the PC decided that arbitrarily, so don't ask me). If the signature is there the program is written into memory starting from the beginning of the boot sector, and that program will start executing.

**Boot**. Refers to a singular form of the noun "Boots", but what does it have to do with the startup of PC? It should be called start. Actually this Boot is an abbreviation of the word "Bootstrap", which originally is the "knob leather" attached to boots. However since the story "The Adventures of Baron Horafuki" the word bootstrap has come to mean "achieve it on your own". So even though the OS is on the disk, the program that reads the OS (IPL) is also on the disk. So it's similar to "the key to open the treasure box is in the treasure box". So it seems like they started calling the OS self-starting mechanisms after that. Well personally I'd call it the "multi-stage rocket launch" method rather than bootstrap method.
