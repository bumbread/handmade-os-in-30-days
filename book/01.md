
## Chapter 01 / From PC structure to assembly (day 1) {#ch01}

### 1. Anyway let's go! {#ch01-01}

Well it's easier to make the OS than to write about it, so we'll start development right now. And so as if ignoring the introduction, I will start developing not in C, nor in assembler, but with a different tool :D

There are programs called Binary Editor (or more widely known as "Hex Editor"). They are used to edit the bytes of a file directly. I would like to use such a program to create a file with contents shown below.

![](media/target_image_start.png)

There may be people who have never seen such a tool before, so let me explain in detail.

If you start it, you should a screen that looks somewhat like this:

![](media/empty_hexedit.png)

Now let's start inputting the data. First type `eb4e904845...` (as shown on the first image). The space is inserted automatically you don't have to enter it. Also you don't have to enter `.N.HELLOIPL...` as on the right screen. That screen is like an "extra" thing so don't worry about it now.

Starting from offset `000090` until `168000` (the file offsets are displayed on the left by the way) the file is full of `00`. If you keep pressing 0 you will be able to fill the file with zeroes... eventually. You can also try asking your cat to hold the key for you or press the key down with a heavy object, like a book.

![](media/cat.png)

![](media/target_image_end.png)

You may not be able to input that all at once, so you may want to save the file. I recommend naming the file `helloos.img`.

Well, turns out that my cat is capricious and I don't read books often. In such a case you can select a whole range and then copy-paste it. Its a convenient world <3.

Ah, right, forgot. Around `0001f0` and `001400` there are parts that are not just `00`. Please enter it like shown in the pictures below and make sure you make no typos.

![](media/target_01f0.png)

![](media/target_1400.png)

So save this and your're done with the disk image. If you look at the properties of the file, you should see 1474560 bytes (= 1440\*1024 bytes). If you write this to a floppy disk (described later) and boot PC from that disk...

![First OS?](media/image_target_launched.png)

And so "hello, world" is displayed. For the time being, that's all, but anyway it started automatically right after the power turned on. Yay! By the way there's no way to exit, so please remove the disc and then turn power off the PC or press the reset button.

---

Of course the number of PC's that can read floppy disks is quite small. That's why you can write the image file not to a floppy disk, but to a CD disk or even a USB stick. Or better, use an emulator, which I'll describe next.

To install the disk image onto USB, for Windows users, first open Win32DiskImager. Choose the image file that you want to write, and make sure that the disk it writes to is the correct USB. Then click "write" and confirm. After some time the image should get written and you'll be notified.

---

In order to test our OS you need to write the image onto USB and make your BIOS recognize USB as the first boot option. If your motherboard has UEFI, make sure that UEFI will either autodetect which boot protocol to use (BIOS or UEFI), or set it to BIOS. In the boot order settings make sure that BIOS tries to boot from USB first, and then from the hard drive. Otherwise it will boot back into Windows (or whatever you're using).

---

There probably are people who don't want to bother buying a USB or people who don't want to bother restarting their PC. In such a case you can use an emulator.

To use an emulator launch a command line (first use of command line!). To start qemu from console type:

```
qemu-system-i386 helloos.img
```

Into the prompt. Now QEMU should start displaying the string "hello world" (among other text).

Ah, also when you start the QEMU the way I showed you you may find the following message:

```
WARNING: Image format was not specified for 'helloos.img' and probing guessed raw.
         Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted.
         Specify the 'raw' format explicitly to remove the restrictions.
```

Even with this warning our OS should be working fine. But in the future, when we would like to perform writes to disk, they would be rejected by QEMU. So we would like to get rid of this warning. In order to fix the warning you have to specify disk image using `-drive` option, like this:

```
qemu-system-i386 -drive format=raw,file=helloos.img
```

Make sure you *don't* put space after the comma. This will tell QEMU that we're explicitly loading a raw image.

Now if you did everything that was told and even then it didn't go well, then I'm pretty sure you are a honest person who steadily copied binary data from the screenshots. I can't tell where you made a mistake, but be sure to check the range from `000000` to `000090` and the data around `00001f0`. Even then if you can't make it work, consider trying out helloos.img from the days/01_v1 folder in cdrom.

If you're a really sloppy person you could have just used helloos.img from the start, without typing it all out. But I think that this experience (typing it the hard way, fixing the mistakes the hard way, then somehow managing to get it working) is valuable. So if you can I recommend you to experience that once.

---

So well, we've come to a point where we built our own OS without modifying other OS'es (if you accept it as OS). This is an amazing thing. I think it's good if you show it off to your friends. Letting the beginner make an OS from absolute scratch in just a few hours -- this book has got to be good, haha. Since inputting is hard this time we only output a message to the screen, but if you keep typing for long enough (within 1440 KB), in principle you can make any OS. One problem is that we don't know what these "EB 4E 90 48 45..." mean (though it's also the biggest problem). So the rest of today and the next 29 chapters will essentially explain nothing but that.

### 2. What did we do? {#ch01-02}

Let me explain why we can only make an OS this way.

We'll start with what the PC actually is. The center of all the processing in the PC is the CPU. CPU is short for Central Processing Unit, so it's obvious that it's in the center. Even if another device was the center of all processing that device would be called the CPU. At the end CPU is always the center of processing. So this CPU can't do much but send electric signal to other circuits. Moreover it can only understand two kinds of signals: ON and OFF, so it's a pretty incompetent device.

We use the PC to write text, listen to music, process images and much much more. In any case the CPU just sends out electrical signals that are either OFF or ON. The CPU doesn't understand the contents of the sentence, the pleasantness of music nor the beauty of the photos. I'd say that it's more like "If you combine these electrical signals like this you will get an electrical signal like that". You can instruct the CPU to perform calculations like addition, subtraction and even multiplication and division of integers. You can also use negation, and not only that, you can use fractions and numbers as big as 10^100. You can extract square roots, which is taught in middle school and you can use the trigonometric functions, taught in high school, with just a single instruction. But the CPU doesn't even understand the concept of a number. It just reacts to these electrical signals and answers with the corresponding electrical signals.

Since the text became hard to understand let's be specific. Let's assume that ON is 1 and OFF is 0, that way it will be easier to understand for ordinary people. If we do that, 

![](media/bits.png)

These 32x16=512 ON's and OFF's signals will represent this poorly written picture.

The string of the following 32 electric signals:

```
00000000000000000000010010100010
```

Represents the integer 1186 (note: if you write 1186 in binary it will be 10010100010). Moreover,

```
01001011010011110100111101000010
```

These 32 electric signals represent the word BOOK (Note: this is how it's actually represented in the PC).

So if these signals are passed, the CPU doesn't know at all whether its part of an image, or a sound wave, whether its a number or part of a sentence, whether its part of a program or a game's save data. It doesn't know, but it doesn't worry about these things, it just silently executes the program.

---

Originally the CPU has been been developed as a device that processes only electric signals. No one thought that it'd become such a useful machine. However by associating OFF and ON with numbers 0 and 1 it was possible to treat electric signals as binary numbers, and on the countrary binary numbers can be treated as electric signals, so it became possible to use it as a binary computer.

Decimal numbers can be converted into binary numbers and binary numbers can be converted back into decimal. So it was possible to do ordinary calculations. Additionally, by assigning numbers to characters (these are also called character codes) it becomes possible to process sentences (like searching through text). After that they learned how to make music and pictures correspond to electronical signals so it became so the range of use for the CPU steadily expanded. But even then CPU is only processing electric signals.

What's more, the CPU not only processes the data. Instructions to the CPU are given by the electric signals. The program we're creating is that machine language, but this machine language is sent to CPU in the form of electric signals. This is just a series of numbers for instructions, so of course its just a bunch of zeroes and ones.

Floppy disks simply replace zeroes and ones with magnetic N's and S's. So image files can only be written as zeroes and ones. Not only image files, but any files on PC can only be written as zeroes and ones. Rather, anything that can't be represented as zeroes and ones can not be passed to the CPU as electric signals, so it can't be processed by the PC.

---

On the other hand "binary editor" is literally "binary number editor". So you can enter whatever blob of binary data and create a file. That's why it's the ultimate strongest weapon. There does not exist a file that can't be created with a binary editor (Oh\~!). If you want some software sold at the store, but you can't buy it, you can just enter it at home with a binary editor. With this you can create exactly the same thing as in the store. Don't worry if you can't buy a 5MP digital camera. As long as you have binary editor you can create any image file that is exactly the same as the JPEG files taken by 5 megapixel digital camera. Don't cry about not being able to get an expensive C compiler. With a binary editor alone you can create an executable file with the same result as the compiler would generate. More than that you can just create the compiler itself!

Since it is the strongest tool, we can create an OS with it. So its obvious why today we awkwardly made an OS. You may wonder whether there was any need to put up such a long explanation just to say this. But once you understand the basics of CPU, the story in the further chapters will be much more clear. So I'm sorry for now. Please accept it.

> "Oi, wait a bit, punk. The Binary Editor is supposed to edit binary numbers, but when I typed your helloos.img, I was forced to enter more than just 0 and 1! In the very beginning there is an `E`. How in the world is this a binary number? It's a friggin' alphabet".

Oops, I give you my apology. You're right.

Binary numbers have excellent compatibility with electric signals, but they have a lonely drawback of having a lot of digits. For example if you write 1234 in binary numbers you get `10011010010`, which is just 11 digits. In decimal it was just 4, right? That's a waste of paper so we use hexadecimal numbers in this industry. In hexadecimal 1234 becomes `4D2` which is just 3 digits.

If you wonder why would I bring out hexadecimal all of a sudden where decimal should have worked just fine, but in fact it's because binary is very easy to convert to hexadecimal,

<table>
    <tr><th colspan=4>Binary &lt;=&gt; Hexadecimal conversion table</th></tr>
    <tr><td>0000 = 0</td><td>0100 = 4</td><td>1000 = 8</td><td>1100 = c</td></tr>
    <tr><td>0001 = 1</td><td>0101 = 5</td><td>1001 = 9</td><td>1101 = d</td></tr>
    <tr><td>0010 = 2</td><td>0110 = 6</td><td>1010 = a</td><td>1110 = e</td></tr>
    <tr><td>0011 = 3</td><td>0111 = 7</td><td>1011 = b</td><td>1111 = f</td></tr>
</table>

So by taking our binary number, we can separate it into 4-digit sequences, and then using the table above to convert each one of these sequences into a single hexadecimal digit,

```
100 1101 0010 -> 4D2
```

We get `4D2`. Similarly, `4D2` can be easily converted to `10011010010` by doing the opposite. Decimal can not be converted to binary as easily. And for the same reason octal notation, which separates binary numbers by 3 digits is also used.

That's why when you typed `EB` you typed `11101011`. So it's a hex editor but think of it as a binary editor.

---

I do compliment hex editors extremely, but its not much different from saying "You can write any great novel with just a piece of paper and a pencil". Paper and pencils are paper and pencils, they are not easy to write great novels. That's why everyone uses a text editor and a compiler when they write programs, not a hex editor. Also when taking photos a digital camera is used, not a hex editor. That's why we also will stop using a hex editor and use a programming langauge from now on. But anyway, a hex editor is a tool useful in cases of emergency. So I will use it in the case of an emergency from now on.

### 3. First assembler experience {#ch01-03}

So now let's use an assembler to generate exactly the same helloos.img as before. We will use an assembler called NASM, which is quite famous in free software.

```
; A very long source program
DB 0xeb, 0x4e, 0x90, 0x48, 0x45, 0x4c, 0x4c, 0x4f
DB 0x49, 0x50, 0x4c, 0x00, 0x02, 0x01, 0x01, 0x00
DB 0x02, 0xe0, 0x00, 0x40, 0x0b, 0xf0, 0x09, 0x00
DB 0x12, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00
DB 0x40, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x29, 0xff
;                      ...
;     -------- 184314 LINES OMITTED --------
;                      ...
DB 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
```

By making full use of copy and paste make a super long source program and save it into the folder with the filename "helloos.asm". As you can see the data within the file is the same as you just typed into a hex editor.

Then compile it by typing the following command:

```
nasm helloos.asm -ohelloos.img
```

It's the first assembler experience! But I think it's terrible anyway. Creating a source program with more than 180000 lines is very difficult and we waste disk space. Even if we do a thing like this, it would have been easier to just use a hex editor since we don't have to type "0x" or ",".

So I decided to not only use the `DB` instruction but also the `TIMES` pseudo-instruction and made helloos.asm much shorter, but of course the result hasn't changed. Please have a look:

```
; A decent length source program
DB 0xeb, 0x4e, 0x90, 0x48, 0x45, 0x4c, 0x4c, 0x4f
DB 0x49, 0x50, 0x4c, 0x00, 0x02, 0x01, 0x01, 0x00
DB 0x02, 0xe0, 0x00, 0x40, 0x0b, 0xf0, 0x09, 0x00
DB 0x12, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00
DB 0x40, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x29, 0xff
DB 0xff, 0xff, 0xff, 0x48, 0x45, 0x4c, 0x4c, 0x4f
DB 0x2d, 0x4f, 0x53, 0x20, 0x20, 0x20, 0x46, 0x41
DB 0x54, 0x31, 0x32, 0x20, 0x20, 0x20, 0x00, 0x00
TIMES 16 DB 0x00
DB 0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7c
DB 0x8e, 0xd8, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8a
DB 0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09
DB 0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xeb
DB 0xee, 0xf4, 0xeb, 0xfd, 0x0a, 0x0a, 0x68, 0x65
DB 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72
DB 0x6c, 0x64, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00
TIMES 368 DB 0x00
DB 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa
DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00
TIMES 4600 DB 0x00
DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00
TIMES 1469432 DB 0x00
```

Typing it out might be a bit of a hassle, so I put this program into the days/01_v2 folder. By the way we don't need the days/01_v1 folder anymore so you may delete it, or keep it as a keepsake. By the way I made days/01_v2 folder by changing the name of days/01_v1 folder, removing unneeded files and adding the necessary files. That's how the folders are growing little by little.

---

The DB instruction is an abbreviation for "Data Byte". That is to write 1 byte directly to the file. I like writing assembly instructions in uppercase, but they can be written in lowercase like "`db`" without any problems.

This instruction is the ultimate strongest weapon in the world of assembler. That is, any data (and any program, by the way) can be written with just that instruction. That's why there are no files that can't be created in assembler. You can create text files, image files, whatever you're told to do, you can do it in assembler. This versatility(?) is rare in other languages (e.g. C).

The TIMES pseudo-instruction with a meaning of something like "Repeat the following instruction 10 times", so you'd use it like `TIMES 10 \<instruction\>`. In our case we repeated `DB 0x00`, command so that's equivalent filling the space with that number of zeroes.

---

If you add "0x" in front of a number, it is a hexadecimal number, and if you don't add it, its a decimal number. That's the same as in the C language.

### 4. Let's rewrite it a little more {#ch01-04}

I'm really happy with 22 lines, but it still has no meaning. So, I added a bit of meaning to it. The file has increased in length to 50 lines. You can find it in days/01_ch5. Now you don't need the days/01_v2 folder. You can delete it or keep it as a keepsake.

The file is 50 lines. I don't think it'll hurt if I leave it on the page.

```
; hello-os

; Description of the FAT-12 floppy disk
DB 0xeb, 0x4e, 0x90
DB "HELLOIPL"            ; Name of boot sector (8 bytes)    (choose any)
DW 512                   ; Sector size in bytes             (don't change)
DB 1                     ; Size of cluster                  (don't change)
DW 1                     ; FAT start sector
DB 2                     ; Number of FAT's                  (don't change)
DW 224                   ; Number of root directory entries
DW 2880                  ; Size of disk in sectors          (don't change)
DB 0xf0                  ; Media type                       (don't change)
DW 9                     ; Sectors per FAT                  (don't change)
DW 18                    ; Sectors per track                (don't change)
DW 2                     ; Number of heads                  (don't change)
DD 0                     ; LBA of first partition           (don't change)
DD 2880                  ; Size of disk in sectors (again)  (don't change)
DB 0,0,0x29              ; Some stuff                       (don't change)
DD 0xffffffff            ; Volume serial                    (choose any)
DB "HELLO-OS   "         ; Disk labbel (11 bytes)           (choose any)
DB "FAT12   "            ; Filesystem name                  (don't change)
RESB 18

; The program
DB 0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7c
DB 0x8e, 0xd8, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8a
DB 0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09
DB 0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xeb
DB 0xee, 0xf4, 0xeb, 0xfd

; The messages
DB 0x0a, 0x0a                ; Two line breaks
DB "hello, world"
DB 0x0a                      ; Line break
DB 0

TIMES 0x1fe-($-$$) DB 0x00   ; Filling up 0x00 until 0x1fe
DB 0x55, 0xaa

; Not boot sector
DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00
RESB 4600
DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00
RESB 1469432
```

For the new highlights, `;` marks a line comment, equivalent to `//` in C or C++. Thanks to these, you can add various comments into a source program. I have been using comments before to describe the programs :D

Next is a new way to use DB instructions. You can write a string of characters. When you write a string it looks up the character code for each character, one by one and writes it into the file byte by byte. This is useful, for example when you want to change a message you don't have to stare at the character code table.

The rest are the DW and DD instructions. These are abbreviations for "Data Word" and "Data Double-word". Word in the world of PC means 16 bits, which is 2 bytes. A double word is 32 bits, which is 4 bytes.

Oops forgot to explain `RESB 0x1fe-($-$$)`. You can read the value `($-$$)` as "number of bytes from the beginning". In this program there are 132 bytes prior to this line so `($-$$)` here is 132. That's why NASM subtracts 132 from 0x1fe to get the answer 378, so it will reserve 378 bytes (and fill with zero).

In that case it seems like you should just write 378 directly without using $, but if you change the message from "hello world" to "this is a pen", how many zeroes it should put will change automatically. That's important because if you don't get `55 AA` at 510-th byte, you won't be able to boot from a floppy. If you write the problem using the dollar sign the assembler will do all the calculations of how many zeroes you have to enter so you can easily modify the program.

This makes it easy to modify the messages, so please modify them according to your liking. This way you can get the only OS in the world with that message, your personal OS.

Finally, I will explain the technical terms that appeared in the source program. Well it's late at night, so that's it for today. Other explanations are for tomorrow.

**FAT12 format**. When a floppy disk is formatted with Windows or MS-DOS it will be formatted in this format. I decided to push an OS into it. That way you won't get angry by windows and you will be store any files you like in that space.

**Boot sector**. The first sector of a disk. The question is "what is a sector?". The hard drives and floppy drives were designed to read 512 bytes at a time. That's why 512 bytes is called a sector. A floppy disk is 1440 KB or 1474560 bytes, but if you divide this by 512 you get 2880. So the floppy disk consists of a total of 2880 sectors. So why is the first sector called a boot sector? The PC first reads the first sector of the disk. Then it looks at the last two bytes. If it isn't 55 AA, it determines that the disk doesn't have the program needed to boot, and you'll get an error saying that the disk is not bootable (You might wonder "why 55 AA". The people who created the PC decided that arbitrarily, so don't ask me). If the signature is there the program is written into memory starting from the beginning of the boot sector, and that program will start executing.

**IPL**. Initial Program Loader. The boot sector is only 512 bytes, so no unlike hello-os, other OS'es don't fit on a boot sector. That's why almost all OS'es have a program in the boot sector that reads the OS itself. For that reason the boot sector is sometimes called the IPL. Though the hello-os doesn't have the ability to load programs so the name "HELLOIPL" is kind of strange. If there are people with a sense of justice who think "I won't allow such a lie!", please change the name. You have to make it exactly 8 bytes, so if it is 7 bytes, just insert a space at the end.

**Boot**. Refers to a singular form of the noun "Boots", but what does it have to do with the startup of PC? It should be called start. Actually this Boot is an abbreviation of the word "Bootstrap", which originally is the "knob leather" attached to boots. However since the story "The Adventures of Baron Horafuki" the word bootstrap has come to mean "achieve it on your own". So even though the OS is on the disk, the program that reads the OS (IPL) is also on the disk. So it's similar to "the key to open the treasure box is in the treasure box". So it seems like they started calling the OS self-starting mechanisms after that. Well personally I'd call it the "multi-stage rocket launch" method rather than bootstrap method.
