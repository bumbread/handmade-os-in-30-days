
## Chapter 02 / Learning assembly and introduction to makefiles (day 2) {#ch02}

TN/TODO: makefiles are bloat, figure out whether it is possible to do a reasonable shell script introduction instead. Check whether rebuilding the whole OS every time is fast enough on older computers.

### 1. Resuming development {#ch02-01}

Yesterday I didn't finish explaining the parts with comments in NASM. So for the part that comes before "The program itself" and the "The part that is not boot sector" part, we'll need more detailed knowledge about the floppy disks, so I will explain those later.

With this only "The program itself" remains. So let's, bit by bit, rewrite it into an easy to understand form. Open the file day02_00/helloos.asm. I'll write the relevant part of the file below.

```
; hello-os
    ORG 0x7c00

    JMP entry
    DB 0x90
; --- [17 LINES OMITTED] ---

; The program itself
entry:
    MOV AX, 0                ; Register initialization
    MOV SS, AX
    MOV SP, 0x7c00
    MOV DS, AX
    MOV ES, AX

    MOV SI, msg

putloop:
    MOV AL, [SI]
    ADD SI, 1                ; Add 1 to SI
    CMP AL, 0
    JE fin
    MOV AH, 0x0e,            ; Display one character function
    MOV BX, 15               ; Color code
    INT 0x10                 ; Call to BIOS
    JMP putloop
fin:
    HLT                      ; Stop CPU until something happens
    JMP fin                  ; Infinite loop

; The part with messages

msg:
    DB 0x0a, 0x0a         ; Two line breaks
    DB "hello, world"
    DB 0x0a               ; Line break
    DB 0

    RESB 0x1fe-($-$$)     ;

    DB 0x55, 0xaa

; The part that is not boot sector
; --- [5 LINES OMITTED] ---
```

We got a whole lot of new instructions. Let's look at them starting from the top.

---

The first command is the ORG command. This is a command to tell NASM where the machine language will be loaded into memory, when ran. Without it some instructions can't be translated to machine language directly. The meaning of $ then becomes the in-memory address of the current instruction, rather than the offset from the start of the file.

TN: By the way `$$` means the in-memory address of the start of the current section. A section is some bundle of code or data within the program that could be independently loaded. We didn't declare any sections, so there was only one section which is the whole file. Therefore in our case basically `$$` meant the in-memory starting address of the loaded bootsector. Naturally if you subtract the address of current instruction in-memory from the in-memory address of the bootsector (do `$-$$`), you get an offset within the file. The author's modified NASK assembler was simplified in such a way, where NASK's "`$`" meant what in NASM is `$-$$`.

The word ORD comes from the word "origin", meaning "starting point". The instruction says something like "By the way the program starts at address XXXX, so thank you for handling the rest, NASM-kun". Here we specify the address 0x7c00, but the reason for that is explained later (towards the end of this chapter).

---

Next comes JMP instruction. This is like goto statement in C. Comes from the word "Jump". Its easy right\~?

The next part is "`entry:`", which is a label declaration. It is used to specify where JMP performs the jump to.

---

Next... looks like it's the MOV instruction. The MOV instruction is probably the most frequently used instruction after DB. Basically all it does is an assignment. It's a very simple instruction, but I think that if you master this instruction you will understand more than half of the assembler. So I will explain it carefully.

`MOV AX, 0` is an assignment statement that says AX=0. Similarly `MOV SS, AX` is an assignment statement that says `SS=AX`. I hear the voices saying "By the way what are these AX and SS?". Please wait a moment, I'll explain it.

The MOV instruction name comes from the english word "move", but it's a little bit different from the traditional sense of the word. If you move, the place where you moved from will become empty. But in assembler if you execute `MOV SS, AX`, AX does not become empty, its value is left as it was. That's why it's actually an assignment. It would have been easier to explain if the instruction was named "copy". I don't understand why did they named it MOV.

Now let's talk AX and SS. The CPU has a memory circuit called a register, which is just like a variable in the machine language. It has 8 typically used registers. Each of them has a real name, but not that many people know them so let me introduce them.

- **AX** - accumulator
- **CX** - counter
- **DX** - data
- **BX** - base
- **SP** - stack pointer
- **BP** - base pointer
- **SI** - source index
- **DI** - destination index

These are all 16-bit registers, meaning that each one of them is capable of holding 16-bit numbers. Each of them has a real name, but calling them by alphabet like "AX" is more natural.

Even though, the real names do make sense. You can perform the same calculations using any of these registers, but if you use AX for cumulative operations, your program may be writen more concisely. To give an example:

```
    ADD CX, 0x1234    is  81 C1 34 12     which is a 4-byte instruction
    ADD AX, 0x1234    is  05 34 12        which is a 3-byte instruction
```

I think you can understand it from the example above, but being able to write consicely here means that the machine language is short, not that the assembler is short. If you don't understand the machine language, the code may be difficult to understand.

As for the other registers, CX is designed to be useful for counting, BX as a starting point for memory address calculations. Similar logic applies to the other registers.

In the names of AX, CX, DX and BX the letter X is a common suffix. I couldn't find any information on this, but most likely it means "extended". In the past there was a time when they used 8-bit registers, so 16-bit registers were amazing compared to that. That's why it has an X saying "It's an expansion, it's amazing!". The registers are not arranged in an alphabetical order, but that is because they are arranged by their number in the machine langauge. It's not my whim.

TN: If you're interested, the X only started being attached to register names in the Intel 8086 processors, which is Intel's first 16-bit processor. Before that the registers were named: A,F,B,C,D,E,H,L, which is a different order.

Even if all of the 8 registers are combined, it would be 16 bytes in total. In other words using all of the registers the CPU can only store 16 bytes.

The CPU also has 8 eight-bit registers.

- **AL** - accumulator low
- **CL** - counter low
- **DL** - data low
- **BL** - base low
- **AH** - accumulator high
- **CH** - counter high
- **DH** - data high
- **BH** - base high

The names are a bit similar, but there is a reason for that. The low 8 bits, in other words bits 0 to 7 of the AX register make up the AL register. The bits 7 to 15, in other words the remaining 8 bits make up the AH register. The number of registers has increased but if you thought "Yess! We got 8 more bytes!", it's not quite that, because the CPU still can store up to 16 bytes. CPU doesn't seem to have a lot of memory.

![](media/registers.png)

By the way can BP,SP,SI and DI be split into L and H parts? If you thought that, you have a really good taste, but no they can't be split like that. It seems like Intel designers think that if you really need to separate them, do a MOV AX,SI and then use AL or AH.

"Hey my PC isn't 16 bits, its 32 bits. 32 bits means it can process data 32 bits at a time, right? Where are the 32 bit registers?". This question might come out soon, so I'll answer it.

```
    EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI
```

These are the 32 bit registers. We haven't used them in our program but you can use them in our program without any problems. The register names are just the names of the 16-bit registers beginning with E, which means "extend". From 16 bits to 32 bits it was a big expansion. EAX is a 32 bit register, but as always it is split into 16-bit parts, and so the low 16-bits of EAX is what AX is. If you wonder about how the top 16 bits are called, the truth is that they dont have a name. Nor a machine code number. So EAX is split into 16 bit parts, but you can only use the lower 16 bits easily. If you want to use the top bits no matter what you can pull them down and access them through AX.

Well that's why the 32-bit CPU can only store 32 bytes. It's very limited in memory.

I'm sure that some readers use 64 bit PC, but we won't use a mode that can use 64-bit registers, so I'll leave the explanation at this.

I'd like to end the introduction of registers here, but oh, there are more. This time I'd like to introduce you registers called Segment Registers. These are 16-bit registers.

- **ES** - extra segment
- **CS** - code segment
- **SS** - stack segment
- **DS** - data segment
- **FS** - no name (extra segment 2)
- **GS** - no name (extra segment 3)

And so I won't explain these registers this time. Sorry. I'll explain them tomorrow, but for today if you leave all of them at 0, there won't be any problems for now.

Well, that's enough for the explanation of the registers.

---

Let's continue reading the program. We see `MOV SI, msg`. The meaning should be `SI = msg`, but the `msg` is defined below as a label. What does it mean to assign a label to a register?

To solve this mystery let's go back to the JMP instruction. There was an instruction `JMP entry`, which in fact can be rewritten as `JMP 0x7c50`. Originally JMP instruction expects memory address as an operand, so this means that means that we're jumping to the program at address `0x7c00`.

The reason why `JMP entry` is replaced by `JMP 0x7c50` is because `entry` has the value `0x7c50`. Which value the labels become depends on the ORG instruction. The assembler calculates "at which address will this part be loaded into memory", and that value is used as the label value.

So if you write `MOV AX, entry`, the number 0x7c50 will be assigned to AX. It is just a number that enters AX, there's nothing ridiculous like "program being assigned to AX" happening.

Then, what happens when we do `MOV SI, msg`? Here msg is 0x7c74, so 0x7c74 is assigned to SI.

---

Next up is `MOV AL, [SI]`. If it was `MOV AX,SI`, we wouldn't need an explanation, but note the `[]`. If you add these brackets, the meaning changes a bit, so I think to explain it thoroughly.

These brackets mean that the operand is a memory operand. If you ever built a PC yourself you should know what memory is. 256MB, 512MB that stuff refers to memory.

![Memory](media/ram.jpeg)

Now that the embarrassing memory capacity of the CPU has been revealed, it is obvious that a separate storage circuit must be prepared in order to do any proper information processing. Even a 32-bit CPU can only store only 32 bytes of memory, or 44 bytes if we include those obscure segment registers. This is not nearly enough to fit a boot sector thats required for the PC to boot.

It's not only when the data is exchanged the CPU communicates with memory. The program itself is always located somewhere in memory. Since usually programs don't fit into 44 bytes, there's no way to fit it into the registers. When CPU executes machine language it always reads it from memory, one instruction after another and executes them in order.

Even though memory-kun is so important it is quite far from the CPU. Of course it may be about 10 cm away, but this is much farther than the semiconductor in the CPU. So when CPU asks memory to tell or store the data, quite some time passes. But CPU runs so fast that even the time for which the electrical signal travels a short distance of just 10 cm might be a problem. So while memory can remember much more than registers, it is much slower. If you keep this in mind you'll be able to write faster programs.

![](media/memory_vs_register.png)

---

Now with that basic knowledge let's get back to the assembler. Not only can we specify registers and numbers as the operands to the MOV instruction but also memory locations. We use `[]` to specify memory locations. We can also use the words BYTE, WORD, and DWORD. Let me give you an example.

```
    MOV BYTE [678], 123
```

This is an instruction to have the number 123 be remember at memory location number 678. Of course if you write it in decimal it will look decent, but that's not how the CPU and memory understand those. The 678 is the lining up of electric signals which are ON and OFF, and when they line up, the eight storage elements somewhere in the circuit react. So these eight storage elements remember the number 123 which is also represented by eight electrical signals. The reason it's 8 storage elements is because we specified BYTE. Similarly you can write:

```
    MOV WORD [678], 123
```

in which case the storage element at address 678, and the adjacent element at address 679 will react. 123 is now a 16 bit number that can be written as 00000000001111011. The low 8 bits (01111011) will be stored at the lower address 678, and the top 8 bits (00000000) will get stored at address 679.

![](media/endianness.png)

---

So when we write memory address in assembler we write:

```
    DATA_SIZE [ ADDRESS ]
```

If you specify BYTE for DATA_SIZE, then only the byte at a given address will be targeted. If you write WORD, that byte and the next byte will get targeted. If you write DWORD that byte and the 3 consequent bytes will be targeted.

Although it is a method of specifying memory addresses, not only constants but also registers can be used. For example like `BYTE[SI]` or `WORD[BX]`. If SI contains the value 987 then `BYTE[SI]` is interpreted as `BYTE[987]`.

I wrote that registers can be used to specify the address, but the registers that can be used are limited, only BX, BP, SI and DI can be used. The remaining registers, AX, CX, DX and SP can not be used. The reason is because CPU doesn't have a circuits to do such processing, and even more the machine language doesn't have a way of specifying these registers. If you have a complaint you can email it to an uncle at Intel (lol). I didn't have the courage to email the complaint, so when I want to load contents of memory at address DX into AX I do:

```
    MOV BX, DX
    MOV AX [BX]
```

---

So now, the instruction to read 1 byte at the address SI to the AL is:

```
    MOV AL, BYTE[SI]
```

However in MOV instruction you can only move between the locations of the same size. So when you use it with 8-bit AL register, only BYTE and no other memory size can be specified. So the size can be omitted and we can just write:

```
    MOV AL, [SI]
```

Ooh, it's the same expression as in the program. It was quite a long explanation. So now you know why this instruction means "load one byte at address SI into AL".

---

The ADD instruction is the addition instruction. `ADD SI, 1` means `SI=SI+1`, when written in C language.

The CMP instruction is a comparison instruction. What is a comparison instruction, you might ask, but that's just a part of a statement. For example in C langauge

```
    if (a == 3) { this and that; }
```

TN/TODO: I think the below explanation really is bad at capturing the meaning.

This means that a is compared with 3. When translating this into machine code you first write `CMP a, 3`, and you have to tell the CPU what to compare with what. And next you write what you want to do when they are equal.

Here we used `CMP AL, 0` which means to compare AL with 0.

The JE instruction is one of the conditional jump instructions. The conditional jump instruction may or may not jump depending on the result of the previous CMP instruction. In this case JE will jump if the operands to CMP were equal. If they weren't equal the instruction following the JE will be executed normally. Which is why the following two instructions:

```
    CMP AL,0
    JE fin
```

Have the meaning of:

```
    if (AL == 0) { goto fin; }
```

The JE is an abbreviation of "Jump if Equal". If the operands are equal the instruction jumps. Also the author uses the label "fin" to signify an end.

---

INT instruction is a software interrupt instruction. If I were to explain the mechanism of interrupts here you'll be left confused, so for now please just think of it as a kind of function call. INT stands for "INTerrupt".

The PC's have a program called BIOS, which is built into an element called ROM on the motherboard of the PC. I am very grateful for the PC makers that have prepared a program that OS makers often use. By the way BIOS is an abbreviation of "Basic Input-Output System".

Recently, BIOS'es are busy with setting the screen settings for the PC and stuff, but for an OS developers, it was originally a collection of functions. So the INT instruction is used to call BIOS functions. By the way the number of the function is written as the operand so you can choose which function to call. This time we used the 0x10 (in other words 16'th) function of BIOS. This is a function related to video card control.

TL/TODO: Leave a link to page describing BIOS functions.

Let's consider a character display function. We'll consider displaying characters one by one and find out how specifically to use a BIOS function that does it.

First, since it is a display function, it is related to video cards. So 0x10 is a good candidate. We'll search the page for INT 0x10 for something like that, and...

```
    Single character display function
    
    AH = 0x0E
    AL = character code
    BH = 0
    BL = color code

    Return value: none

    Note: beep, backspace, CR and LF are recognized as control codes.
```

That's what you find. If you assign various values to registers as specified above and then execute INT 0x10, you will get one congratulatory character on the screen.

---

The last of the new instructions is the HLT instruction. This command is a fairly minor command, and I'm afraid I'm the only person in the world to make this command appear on the second day. There is an author's prejudice involved so let me talk about it hotly (lol).

The HLT instruction is an instruction that causes CPU to stop. But not stop completely (for that, you'll have to turn the power off), rather it goes into a standby state. If then there are any external changes such as keyboard press or a mouse move the CPU will open awaken and continue running the program... this time I'd like to see this program in detail, but at the end it's just an infinite JMP fin loop, with or without HLT instruction. So that's why few people introduce HLT instruction. The explanation just becomes longer.

However I don't like to run CPU meaninglessly. If youe xecute JMP instructions with full power without HLT, the CPU load will naturally be 100% and you will use more and more electricity. Isn't that a waste? Just by inserting HLT your CPU won't waste as much time jumping to the same spot and you won't use as much electricity. Even if you're a beginner it's a good habit of doing HLT if you're not doing anything. Rather, *because* you are a beginner, I'll teach you to do good things from now on. If we are nice to the earth and the electricity bill the life of PC will be extended a little, maybe.

Ah also the HLT instruction is named after the english world "HALT". It means to stop.

---

It was a long explanation, but it's the end of the explanation of the program. If we put it back together it looks like this:


```
    ; hello.asm - rewritten in C language
entry:
    AX = 0;
    SS = AX;
    SP = 0x7c00;
    DS = AX;
    ES = AX;
    SI = msg;
putloop:
    AL = BYTE [SI];
    SI = SI + 1;
    if (AL == 0) goto fin;
    AH = 0x0e;
    BX = 15;
    INT 0x10;
    goto putloop;
fin:
    HLT;
    goto fin;
    
```

In this program data in `msg` was displayed character by character, and once that data is zero, it turns into an infinite loop. So just like this the string "hello, world" was displayed.

---

I think your PC has a lot of memory, maybe 64 MB, maybe 512 MB. But when it comes to using this entire memory as you like, that's not the case. For example the address 0, that's like the very first address is used by BIOS. So if you use it you'll be in a conflict with BIOS, and the BIOS might malfunction. In such case your program will also malfunction, so it'll be a very sad story. On the other hadn BIOS itself is located near 0xf0000, so that memory can't be used either.

There are other memory areas that shouldn't be used here and there, and OS developers have to worry about this. If you use Windows or Linux, the OS will take care of that for you so you don't have to think about such troublesome things, but this time we're taking care of it for other people. So you can make a map of where you can use memory and where you can not use memory. So this is a memory map, please take a look:

TN/TODO: insert link to memory map

```
    0x00007c00..0x00007dff    where the bootsector is loaded
```

This item can't be overlooked. The value of the ORG this time is exactly that number. And because I used this number it went well.

You may have a frank question here. Why 0x7c00? Isn't 0x7000 easier to cut and remember? I think so too, but it was decided to be 0x7c00 anyway. It was probably an IBM uncle. By now he may have become an old man.

And decided once, they do like "I'm going to change it to 0x7000, good luck everybody\~\~". If they did, all existing OS'es that assumed the load address 0x7c00 wouldn't be able to boot, so such a computer wouldn't be able to be sold.

I'm sure there will be many "why"'s in the future, but in the end it was all decided by IBM's uncles and Intel's uncles. Well if you look deeper there are reasons for that, but if I were to explain that all the book would become twice as thick.

### 2. Arrangement to create only the boot sector {#ch02-02}

Considering the future development it's better to have NASM only create the 512-byte boot sector for the time being, and the rest to be created by the disk image creation tool, instead of creating the whole image with NASM.

So I made the helloos in day02_01. First I cut the last part of helloos.asm (the part that is not bootsector). The boot sector only needs to be the first 512 bytes. And since this source file is boot sector only I renamed it to ipl.asm.

TN/TODO: figure out how .lst list file is used. It is a file that tells which assembly instructions were translated to what machine code.

So now the build process is the following. First, as usual, compile your file using NASM.

```
    nasm ipl.asm -o ipl.bin
```

This time I the boot sector output is a .bin file. Then create the ISO image using the command...

TN: yeah... here i'd probably need to create my own ISO creator. If you're using Linux for now I recommend looking into making El Torito image files with mkisofs. I'm not going to write this tool until figure out what an OS close to final is supposed to be like. Sorry for inconvenience.

### 3. Introducing build scripts to use from now on {#ch02-03}

The day02_02 is the same as day02_01, except that now we're using build scripts to simplify the process of creating an OS.

TN: The original book used makefiles here but for out purposes we don't need to use specialised tools with features we don't need. Simple batch scripts work reasonably well even for slow PC's (TODO: verify the claim). This chapter is one big addition by the translator that replaces otherwise equivalent makefile introduction.

Repeating the nasm and qemu commands might not be that exiting when you work on a project. In order to build a project we have to type the NASM command, then type the command that builds an ISO image, and when we want to test our image we type a long command that starts up QEMU.

In Windows and Linux we can create files that run shell commands you have written in order. You can create a file called `make.bat` (on linux name it just `make`). The contents are the following:

Windows:

```
    nasm ipl.asm -oipl.bin
    :: TODO/image building command
    qemu-system-i386 helloos.img
```

Linux:

```
    #!/bin/sh
    nasm ipl.asm -oipl.bin
    # TODO/image building command
    qemu-system-i386 helloos.img
```

Each line runs a separate command, and you can notice that after running nasm and image building we run qemu. If you don't want to do that you can create another file called `run.bat` (`run`) which will just contain the qemu command.

In order to run the file just type

```
    make
```

on Windows. For Linux you have to first add the permission for execution to the file:

```
    chmod u+x make
```

After that you may run it as usual

```
    ./make
```

Make sure not to miss `./`.

---

The difference between makefiles and shell scripts.

Makefiles are made to be useful for complex projects where multiple files are being compiled independently. In such a case you may change just one of the files, so you wouldn't want to recompile the whole project just because of that -- after all, most of the files didn't change so even if compiled repeatedly you'll get the same thing.

So makefiles were created with this explicit purpose in mind -- make compilation time faster by not recompiling files that didn't change. But in order to use makefiles you have to be explicit about which files you recompile, which files do they depend on etc, etc. This will make the explanation longer, but since our OS is small the compilation times should be reasonable for us to not use makefiles. That's all.

